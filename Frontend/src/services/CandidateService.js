import { candidateRankingData } from '../mock/CandidateRankingData';
import { candidateProfileData } from '../mock/CandidateProfileData';
import { apiFetch } from './AuthService';

// Simulated API delay
const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

export const candidateService = {
  // Get job and candidate data
  getCandidateRanking: async (jobId) => {
    // Try real API call to /api/JobIntrinsics; fall back to mock if it fails
    try {
      const res = await apiFetch('/api/JobIntrinsics', { method: 'POST', body: JSON.stringify({ JobID: jobId }) });
      if (!res.ok) {
        // fallback to mock
        await delay(300);
        return candidateRankingData;
      }
      const json = await res.json();

      // Build jobData shape expected by the page
      const job = { id: json.JobID || jobId, title: json.JobTitle || 'Job', link: json.JobLink || json.jobLink || null, status: json.JobStatus || '' };
      // Build stats from candidate ApplicationStatus values
      const allCandidates = (json.Candidates || []);
      // Include ALL candidates, even those not yet evaluated (CVScore = null)
      const candidatesWithScores = allCandidates;
      const countByStatus = (status) => candidatesWithScores.filter(c => String(c.ApplicationStatus || '').trim() === status).length;

      const stats = {
        totalCandidates: json.TotalNumberOfCandidates || 0,
        // Following mapping:
        // interviewInvitesSent -> AI-Interviews Scheduled (Shortlisted For AI-Interview)
        // interviewsScheduled -> Human-Interviews Scheduled (Shortlisted For Human Interview)
        // interviewsPending -> AI-Interviews Completed (AI-Interview Completed)
        // interviewsCompleted -> Human Interviews Completed (Human Interview Completed)
        interviewInvitesSent: countByStatus('Shortlisted For AI-Interview'),
        interviewsScheduled: countByStatus('Shortlisted For Human Interview'),
        interviewsPending: countByStatus('AI-Interview Completed'),
        interviewsCompleted: countByStatus('Human Interview Completed')
      };

      const candidates = candidatesWithScores.map((c, idx) => ({
        id: `${idx}-${c.Email}`,
        rank: idx + 1,
        // If this is an autogenerated placeholder email and FullName is missing,
        // show '?' as avatar initials but keep the visible name as Candidate{n} (CA{n}@example.com).
        initials: (() => {
          const email = (c.Email || '').trim();
          const full = (c.FullName || '') || '';
          const m = email.match(/^ca(\d+)@example\.com$/i);
          if (!full && m) return '?';
          return (full || email).split(' ').map(s => s[0]).join('').slice(0,2).toUpperCase();
        })(),
        name: (() => {
          const email = (c.Email || '').trim();
          const full = (c.FullName || '').trim();
          const m = email.match(/^ca(\d+)@example\.com$/i);
          if (!full && m) return `Candidate${m[1]} (${email})`;
          return full || email || 'Unknown';
        })(),
        email: c.Email || '',
        // Experience: try ResumeBreakdown.Experience; provide text fallback
        experience: [],
        experienceText: (c.ResumeBreakdown && c.ResumeBreakdown.Experience) ? c.ResumeBreakdown.Experience : 'No relevant experience',
        matchScore: c.CompositeScore != null ? c.CompositeScore : null,
        cvScore: c.CVScore != null ? c.CVScore : (c.CV_Score != null ? c.CV_Score : null),
        interviewScore: c.AIInterviewScore != null ? c.AIInterviewScore : (c.AIInterview_Score != null ? c.AIInterview_Score : null),
        compositeScore: c.CompositeScore != null ? c.CompositeScore : null,
        // Include ResumeBreakdown for detailed view
        resumeBreakdown: c.ResumeBreakdown || null,
        // Do not populate flags in the UI at this time â€” keep empty.
        flags: [],
        status: c.ApplicationStatus || '',
        statusColor: c.ApplicationStatus === 'Accepted' ? 'green' : (c.ApplicationStatus === 'Rejected' ? 'red' : 'gray')
      }));

      return { job, stats, candidates };
    } catch (err) {
      console.error('CandidateService.getCandidateRanking API failed, using mock:', err.message || err);
      await delay(300);
      return candidateRankingData;
    }
  },

  // Get candidate profile
  getCandidateProfile: async (candidateId) => {
    // For now, fallback to mock data
    // In the future, this can call a dedicated profile endpoint if needed
    await delay(500);

    const profile = candidateProfileData[candidateId];
    if (!profile) {
      throw new Error('Candidate not found');
    }
    return profile;
  },

  // Get job-specific candidate details from backend
  getJobCandidateDetails: async (jobId, email) => {
    try {
      const res = await apiFetch('/api/JobXCandidateDetails', { method: 'POST', body: JSON.stringify({ JobID: jobId, Email: email }) });
      if (!res.ok) {
        const txt = await res.text();
        throw new Error(txt || `Request failed (${res.status})`);
      }
      const json = await res.json();
      // Expect { JobID, Email, Candidate: { CVLink, CVScore, AIInterviewScore, CompositeScore, ResumeBreakdown, Flags, FullName } }
      return json;
    } catch (err) {
      console.error('getJobCandidateDetails failed:', err.message || err);
      throw err;
    }
  },

  // Accept candidate
  acceptCandidate: async (jobId, email) => {
    try {
      const res = await apiFetch('/api/ChangeApplicationStatus', {
        method: 'POST',
        body: JSON.stringify({ JobID: jobId, Email: email, PromoteTo: 'Accept' })
      });

      if (!res.ok) {
        const error = await res.json();
        throw new Error(error.message || 'Failed to accept candidate');
      }

      return await res.json();
    } catch (error) {
      console.error('acceptCandidate error:', error);
      throw error;
    }
  },

  // Invite candidate for AI interview
  inviteForAIInterview: async (jobId, email) => {
    try {
      const res = await apiFetch('/api/ChangeApplicationStatus', {
        method: 'POST',
        body: JSON.stringify({ JobID: jobId, Email: email, PromoteTo: 'InviteForAIInterview' })
      });

      if (!res.ok) {
        const error = await res.json();
        throw new Error(error.message || 'Failed to invite for AI interview');
      }

      return await res.json();
    } catch (error) {
      console.error('inviteForAIInterview error:', error);
      throw error;
    }
  },

  // Invite candidate for human interview
  inviteForHumanInterview: async (jobId, email) => {
    try {
      const res = await apiFetch('/api/ChangeApplicationStatus', {
        method: 'POST',
        body: JSON.stringify({ JobID: jobId, Email: email, PromoteTo: 'InviteForHumanInterview' })
      });

      if (!res.ok) {
        const error = await res.json();
        throw new Error(error.message || 'Failed to invite for human interview');
      }

      return await res.json();
    } catch (error) {
      console.error('inviteForHumanInterview error:', error);
      throw error;
    }
  },

  // Reject candidate
  rejectCandidate: async (jobId, email) => {
    try {
      const res = await apiFetch('/api/ChangeApplicationStatus', {
        method: 'POST',
        body: JSON.stringify({ JobID: jobId, Email: email, PromoteTo: 'Reject' })
      });

      if (!res.ok) {
        const error = await res.json();
        throw new Error(error.message || 'Failed to reject candidate');
      }

      return await res.json();
    } catch (error) {
      console.error('rejectCandidate error:', error);
      throw error;
    }
  }
  ,

  // Update candidate's FullName in Users collection
  updateCandidateName: async (email, fullName) => {
    try {
      const res = await apiFetch('/api/UpdateUser', {
        method: 'POST',
        body: JSON.stringify({ Email: email, FullName: fullName })
      });
      if (!res.ok) {
        const txt = await res.text();
        throw new Error(txt || `Request failed (${res.status})`);
      }
      return await res.json();
    } catch (err) {
      console.error('updateCandidateName failed:', err.message || err);
      throw err;
    }
  }
};